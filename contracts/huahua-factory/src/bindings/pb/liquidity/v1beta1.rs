// This file is @generated by prost-build.
/// MsgCreatePool defines an sdk.Msg type that supports submitting a create
/// liquidity pool tx.
///
/// See:
/// <https://github.com/tendermint/liquidity/blob/develop/x/liquidity/spec/04_messages.md>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreatePool {
    #[prost(string, tag = "1")]
    pub pool_creator_address: ::prost::alloc::string::String,
    /// id of the target pool type, must match the value in the pool. Only
    /// pool-type-id 1 is supported.
    #[prost(uint32, tag = "2")]
    pub pool_type_id: u32,
    /// reserve coin pair of the pool to deposit.
    #[prost(message, repeated, tag = "4")]
    pub deposit_coins: ::prost::alloc::vec::Vec<
        super::super::cosmos::base::v1beta1::Coin,
    >,
}
/// MsgCreatePoolResponse defines the Msg/CreatePool response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCreatePoolResponse {}
/// `MsgDepositWithinBatch defines` an `sdk.Msg` type that supports submitting
/// a deposit request to the batch of the liquidity pool.
/// Deposit is submitted to the batch of the Liquidity pool with the specified
/// `pool_id`, `deposit_coins` for reserve.
/// This request is stacked in the batch of the liquidity pool, is not processed
/// immediately, and is processed in the `endblock` at the same time as other
/// requests.
///
/// See:
/// <https://github.com/tendermint/liquidity/blob/develop/x/liquidity/spec/04_messages.md>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDepositWithinBatch {
    #[prost(string, tag = "1")]
    pub depositor_address: ::prost::alloc::string::String,
    /// id of the target pool
    #[prost(uint64, tag = "2")]
    pub pool_id: u64,
    /// reserve coin pair of the pool to deposit
    #[prost(message, repeated, tag = "3")]
    pub deposit_coins: ::prost::alloc::vec::Vec<
        super::super::cosmos::base::v1beta1::Coin,
    >,
}
/// MsgDepositWithinBatchResponse defines the Msg/DepositWithinBatch response
/// type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgDepositWithinBatchResponse {}
/// `MsgWithdrawWithinBatch` defines an `sdk.Msg` type that supports submitting
/// a withdraw request to the batch of the liquidity pool.
/// Withdraw is submitted to the batch from the Liquidity pool with the
/// specified `pool_id`, `pool_coin` of the pool.
/// This request is stacked in the batch of the liquidity pool, is not processed
/// immediately, and is processed in the `endblock` at the same time as other
/// requests.
///
/// See:
/// <https://github.com/tendermint/liquidity/blob/develop/x/liquidity/spec/04_messages.md>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgWithdrawWithinBatch {
    #[prost(string, tag = "1")]
    pub withdrawer_address: ::prost::alloc::string::String,
    /// id of the target pool
    #[prost(uint64, tag = "2")]
    pub pool_id: u64,
    #[prost(message, optional, tag = "3")]
    pub pool_coin: ::core::option::Option<super::super::cosmos::base::v1beta1::Coin>,
}
/// MsgWithdrawWithinBatchResponse defines the Msg/WithdrawWithinBatch response
/// type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgWithdrawWithinBatchResponse {}
/// `MsgSwapWithinBatch` defines an sdk.Msg type that supports submitting a swap
/// offer request to the batch of the liquidity pool. Submit swap offer to the
/// liquidity pool batch with the specified the `pool_id`, `swap_type_id`,
/// `demand_coin_denom` with the coin and the price you're offering
/// and `offer_coin_fee` must be half of offer coin amount * current
/// `params.swap_fee_rate` and ceil for reservation to pay fees. This request is
/// stacked in the batch of the liquidity pool, is not processed immediately, and
/// is processed in the `endblock` at the same time as other requests. You must
/// request the same fields as the pool. Only the default `swap_type_id` 1 is
/// supported.
///
/// See: <https://github.com/tendermint/liquidity/tree/develop/doc>
/// <https://github.com/tendermint/liquidity/blob/develop/x/liquidity/spec/04_messages.md>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSwapWithinBatch {
    /// address of swap requester
    #[prost(string, tag = "1")]
    pub swap_requester_address: ::prost::alloc::string::String,
    /// id of swap type, must match the value in the pool. Only `swap_type_id` 1 is
    /// supported.
    #[prost(uint64, tag = "2")]
    pub pool_id: u64,
    /// id of swap type. Must match the value in the pool.
    #[prost(uint32, tag = "3")]
    pub swap_type_id: u32,
    /// offer sdk.coin for the swap request, must match the denom in the pool.
    #[prost(message, optional, tag = "4")]
    pub offer_coin: ::core::option::Option<super::super::cosmos::base::v1beta1::Coin>,
    /// denom of demand coin to be exchanged on the swap request, must match the
    /// denom in the pool.
    #[prost(string, tag = "5")]
    pub demand_coin_denom: ::prost::alloc::string::String,
    /// half of offer coin amount * params.swap_fee_rate and ceil for reservation
    /// to pay fees.
    #[prost(message, optional, tag = "6")]
    pub offer_coin_fee: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// limit order price for the order, the price is the exchange ratio of X/Y
    /// where X is the amount of the first coin and Y is the amount
    /// of the second coin when their denoms are sorted alphabetically.
    #[prost(string, tag = "7")]
    pub order_price: ::prost::alloc::string::String,
}
/// MsgSwapWithinBatchResponse defines the Msg/Swap response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSwapWithinBatchResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDirectSwap {
    /// address of swap requester
    #[prost(string, tag = "1")]
    pub swap_requester_address: ::prost::alloc::string::String,
    /// id of swap type, must match the value in the pool. Only `swap_type_id` 1 is
    /// supported.
    #[prost(uint64, tag = "2")]
    pub pool_id: u64,
    /// id of swap type. Must match the value in the pool.
    #[prost(uint32, tag = "3")]
    pub swap_type_id: u32,
    /// offer sdk.coin for the swap request, must match the denom in the pool.
    #[prost(message, optional, tag = "4")]
    pub offer_coin: ::core::option::Option<super::super::cosmos::base::v1beta1::Coin>,
    /// denom of demand coin to be exchanged on the swap request, must match the
    /// denom in the pool.
    #[prost(string, tag = "5")]
    pub demand_coin_denom: ::prost::alloc::string::String,
    /// limit order price for the order, the price is the exchange ratio of X/Y
    /// where X is the amount of the first coin and Y is the amount
    /// of the second coin when their denoms are sorted alphabetically.
    #[prost(string, tag = "7")]
    pub order_price: ::prost::alloc::string::String,
}
/// MsgSwapWithinBatchResponse defines the Msg/Swap response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDirectSwapResponse {
    #[prost(message, optional, tag = "1")]
    pub received_amount: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
}
/// WeightedAddress represents an address with a weight assigned to it.
/// The weight is used to determine the proportion of the total minted
/// tokens to be minted to the address.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeightedAddress {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub weight: ::prost::alloc::string::String,
}
/// Structure for the pool type to distinguish the characteristics of the reserve
/// pools.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolType {
    /// This is the id of the pool_type that is used as pool_type_id for pool
    /// creation. In this version, only pool-type-id 1 is supported.
    /// {"id":1,"name":"ConstantProductLiquidityPool","min_reserve_coin_num":2,"max_reserve_coin_num":2,"description":""}
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// name of the pool type.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// minimum number of reserveCoins for LiquidityPoolType, only 2 reserve coins
    /// are supported.
    #[prost(uint32, tag = "3")]
    pub min_reserve_coin_num: u32,
    /// maximum number of reserveCoins for LiquidityPoolType, only 2 reserve coins
    /// are supported.
    #[prost(uint32, tag = "4")]
    pub max_reserve_coin_num: u32,
    /// description of the pool type.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
}
/// Params defines the parameters for the liquidity module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Params {
    /// list of available pool types
    #[prost(message, repeated, tag = "1")]
    pub pool_types: ::prost::alloc::vec::Vec<PoolType>,
    /// Minimum number of coins to be deposited to the liquidity pool on pool
    /// creation.
    #[prost(string, tag = "2")]
    pub min_init_deposit_amount: ::prost::alloc::string::String,
    /// Initial mint amount of pool coins upon pool creation.
    #[prost(string, tag = "3")]
    pub init_pool_coin_mint_amount: ::prost::alloc::string::String,
    /// Limit the size of each liquidity pool to minimize risk. In development, set
    /// to 0 for no limit. In production, set a limit.
    #[prost(string, tag = "4")]
    pub max_reserve_coin_amount: ::prost::alloc::string::String,
    /// Fee paid to create a Liquidity Pool. Set a fee to prevent spamming.
    #[prost(message, repeated, tag = "5")]
    pub pool_creation_fee: ::prost::alloc::vec::Vec<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// Swap fee rate for every executed swap.
    #[prost(string, tag = "6")]
    pub swap_fee_rate: ::prost::alloc::string::String,
    /// Reserve coin withdrawal with less proportion by withdrawFeeRate.
    #[prost(string, tag = "7")]
    pub withdraw_fee_rate: ::prost::alloc::string::String,
    /// Maximum ratio of reserve coins that can be ordered at a swap order.
    #[prost(string, tag = "8")]
    pub max_order_amount_ratio: ::prost::alloc::string::String,
    /// The smallest unit batch height for every liquidity pool.
    #[prost(uint32, tag = "9")]
    pub unit_batch_height: u32,
    /// Circuit breaker enables or disables transaction messages in liquidity
    /// module.
    #[prost(bool, tag = "10")]
    pub circuit_breaker_enabled: bool,
    #[prost(message, repeated, tag = "11")]
    pub builders_addresses: ::prost::alloc::vec::Vec<WeightedAddress>,
    #[prost(string, tag = "12")]
    pub builders_commission: ::prost::alloc::string::String,
}
/// Pool defines the liquidity pool that contains pool information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pool {
    /// id of the pool
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// id of the pool_type
    #[prost(uint32, tag = "2")]
    pub type_id: u32,
    /// denoms of reserve coin pair of the pool
    #[prost(string, repeated, tag = "3")]
    pub reserve_coin_denoms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// reserve account address of the pool
    #[prost(string, tag = "4")]
    pub reserve_account_address: ::prost::alloc::string::String,
    /// denom of pool coin of the pool
    #[prost(string, tag = "5")]
    pub pool_coin_denom: ::prost::alloc::string::String,
}
/// Metadata for the state of each pool for invariant checking after genesis
/// export or import.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolMetadata {
    /// id of the pool
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    /// pool coin issued at the pool
    #[prost(message, optional, tag = "2")]
    pub pool_coin_total_supply: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// reserve coins deposited in the pool
    #[prost(message, repeated, tag = "3")]
    pub reserve_coins: ::prost::alloc::vec::Vec<
        super::super::cosmos::base::v1beta1::Coin,
    >,
}
/// PoolBatch defines the batch or batches of a given liquidity pool that
/// contains indexes of deposit, withdraw, and swap messages. Index param
/// increments by 1 if the pool id is same.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PoolBatch {
    /// id of the pool
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    /// index of this batch
    #[prost(uint64, tag = "2")]
    pub index: u64,
    /// height where this batch is started
    #[prost(int64, tag = "3")]
    pub begin_height: i64,
    /// last index of DepositMsgStates
    #[prost(uint64, tag = "4")]
    pub deposit_msg_index: u64,
    /// last index of WithdrawMsgStates
    #[prost(uint64, tag = "5")]
    pub withdraw_msg_index: u64,
    /// last index of SwapMsgStates
    #[prost(uint64, tag = "6")]
    pub swap_msg_index: u64,
    /// true if executed, false if not executed
    #[prost(bool, tag = "7")]
    pub executed: bool,
}
/// DepositMsgState defines the state of deposit message that contains state
/// information as it is processed in the next batch or batches.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DepositMsgState {
    /// height where this message is appended to the batch
    #[prost(int64, tag = "1")]
    pub msg_height: i64,
    /// index of this deposit message in this liquidity pool
    #[prost(uint64, tag = "2")]
    pub msg_index: u64,
    /// true if executed on this batch, false if not executed
    #[prost(bool, tag = "3")]
    pub executed: bool,
    /// true if executed successfully on this batch, false if failed
    #[prost(bool, tag = "4")]
    pub succeeded: bool,
    /// true if ready to be deleted on kvstore, false if not ready to be deleted
    #[prost(bool, tag = "5")]
    pub to_be_deleted: bool,
    /// MsgDepositWithinBatch
    #[prost(message, optional, tag = "6")]
    pub msg: ::core::option::Option<MsgDepositWithinBatch>,
}
/// WithdrawMsgState defines the state of the withdraw message that contains
/// state information as the message is processed in the next batch or batches.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawMsgState {
    /// height where this message is appended to the batch
    #[prost(int64, tag = "1")]
    pub msg_height: i64,
    /// index of this withdraw message in this liquidity pool
    #[prost(uint64, tag = "2")]
    pub msg_index: u64,
    /// true if executed on this batch, false if not executed
    #[prost(bool, tag = "3")]
    pub executed: bool,
    /// true if executed successfully on this batch, false if failed
    #[prost(bool, tag = "4")]
    pub succeeded: bool,
    /// true if ready to be deleted on kvstore, false if not ready to be deleted
    #[prost(bool, tag = "5")]
    pub to_be_deleted: bool,
    /// MsgWithdrawWithinBatch
    #[prost(message, optional, tag = "6")]
    pub msg: ::core::option::Option<MsgWithdrawWithinBatch>,
}
/// SwapMsgState defines the state of the swap message that contains state
/// information as the message is processed in the next batch or batches.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapMsgState {
    /// height where this message is appended to the batch
    #[prost(int64, tag = "1")]
    pub msg_height: i64,
    /// index of this swap message in this liquidity pool
    #[prost(uint64, tag = "2")]
    pub msg_index: u64,
    /// true if executed on this batch, false if not executed
    #[prost(bool, tag = "3")]
    pub executed: bool,
    /// true if executed successfully on this batch, false if failed
    #[prost(bool, tag = "4")]
    pub succeeded: bool,
    /// true if ready to be deleted on kvstore, false if not ready to be deleted
    #[prost(bool, tag = "5")]
    pub to_be_deleted: bool,
    /// swap orders are cancelled when current height is equal to or higher than
    /// ExpiryHeight
    #[prost(int64, tag = "6")]
    pub order_expiry_height: i64,
    /// offer coin exchanged until now
    #[prost(message, optional, tag = "7")]
    pub exchanged_offer_coin: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// offer coin currently remaining to be exchanged
    #[prost(message, optional, tag = "8")]
    pub remaining_offer_coin: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// reserve fee for pays fee in half offer coin
    #[prost(message, optional, tag = "9")]
    pub reserved_offer_coin_fee: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// MsgSwapWithinBatch
    #[prost(message, optional, tag = "10")]
    pub msg: ::core::option::Option<MsgSwapWithinBatch>,
}
/// the request type for the QueryLiquidityPool RPC method. requestable specified
/// pool_id.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryLiquidityPoolRequest {
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
}
/// the response type for the QueryLiquidityPoolResponse RPC method. Returns the
/// liquidity pool that corresponds to the requested pool_id.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLiquidityPoolResponse {
    #[prost(message, optional, tag = "1")]
    pub pool: ::core::option::Option<Pool>,
}
/// the request type for the QueryLiquidityByPoolCoinDenomPool RPC method.
/// Requestable specified pool_coin_denom.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLiquidityPoolByPoolCoinDenomRequest {
    #[prost(string, tag = "1")]
    pub pool_coin_denom: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLiquidityPoolByCoinsDenomRequest {
    #[prost(string, tag = "1")]
    pub coin_denom1: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub coin_denom2: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub pool_type_id: u32,
}
/// the request type for the QueryLiquidityByReserveAcc RPC method. Requestable
/// specified reserve_acc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLiquidityPoolByReserveAccRequest {
    #[prost(string, tag = "1")]
    pub reserve_acc: ::prost::alloc::string::String,
}
/// the request type for the QueryLiquidityPoolBatch RPC method. requestable
/// including specified pool_id.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryLiquidityPoolBatchRequest {
    /// id of the target pool for query
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
}
/// the response type for the QueryLiquidityPoolBatchResponse RPC method. Returns
/// the liquidity pool batch that corresponds to the requested pool_id.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryLiquidityPoolBatchResponse {
    #[prost(message, optional, tag = "1")]
    pub batch: ::core::option::Option<PoolBatch>,
}
/// the request type for the QueryLiquidityPools RPC method. Requestable
/// including pagination offset, limit, key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLiquidityPoolsRequest {
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// the response type for the QueryLiquidityPoolsResponse RPC method. This
/// includes a list of all existing liquidity pools and paging results that
/// contain next_key and total count.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLiquidityPoolsResponse {
    #[prost(message, repeated, tag = "1")]
    pub pools: ::prost::alloc::vec::Vec<Pool>,
    /// pagination defines the pagination in the response. not working on this
    /// version.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryParamsRequest is request type for the QueryParams RPC method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsRequest {}
/// the response type for the QueryParamsResponse RPC method. This includes
/// current parameter of the liquidity module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryParamsResponse {
    /// params holds all the parameters of this module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
/// the request type for the QueryPoolBatchSwapMsgs RPC method. Requestable
/// including specified pool_id and pagination offset, limit, key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchSwapMsgsRequest {
    /// id of the target pool for query
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// the request type for the QueryPoolBatchSwap RPC method. Requestable including
/// specified pool_id and msg_index.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchSwapMsgRequest {
    /// id of the target pool for query
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    /// target msg_index of the pool
    #[prost(uint64, tag = "2")]
    pub msg_index: u64,
}
/// the response type for the QueryPoolBatchSwapMsgs RPC method. This includes
/// list of all currently existing swap messages of the batch and paging results
/// that contain next_key and total count.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchSwapMsgsResponse {
    #[prost(message, repeated, tag = "1")]
    pub swaps: ::prost::alloc::vec::Vec<SwapMsgState>,
    /// pagination defines the pagination in the response. not working on this
    /// version.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// the response type for the QueryPoolBatchSwapMsg RPC method. This includes a
/// batch swap message of the batch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchSwapMsgResponse {
    #[prost(message, optional, tag = "1")]
    pub swap: ::core::option::Option<SwapMsgState>,
}
/// the request type for the QueryPoolBatchDeposit RPC method. Requestable
/// including specified pool_id and pagination offset, limit, key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchDepositMsgsRequest {
    /// id of the target pool for query
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// the request type for the QueryPoolBatchDeposit RPC method. requestable
/// including specified pool_id and msg_index.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchDepositMsgRequest {
    /// id of the target pool for query
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    /// target msg_index of the pool
    #[prost(uint64, tag = "2")]
    pub msg_index: u64,
}
/// the response type for the QueryPoolBatchDeposit RPC method. This includes a
/// list of all currently existing deposit messages of the batch and paging
/// results that contain next_key and total count.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchDepositMsgsResponse {
    #[prost(message, repeated, tag = "1")]
    pub deposits: ::prost::alloc::vec::Vec<DepositMsgState>,
    /// pagination defines the pagination in the response. not working on this
    /// version.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// the response type for the QueryPoolBatchDepositMsg RPC method. This includes
/// a batch swap message of the batch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchDepositMsgResponse {
    #[prost(message, optional, tag = "1")]
    pub deposit: ::core::option::Option<DepositMsgState>,
}
/// the request type for the QueryPoolBatchWithdraw RPC method. Requestable
/// including specified pool_id and pagination offset, limit, key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchWithdrawMsgsRequest {
    /// id of the target pool for query
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// the request type for the QueryPoolBatchWithdraw RPC method. requestable
/// including specified pool_id and msg_index.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchWithdrawMsgRequest {
    /// id of the target pool for query
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    /// target msg_index of the pool
    #[prost(uint64, tag = "2")]
    pub msg_index: u64,
}
/// the response type for the QueryPoolBatchWithdraw RPC method. This includes a
/// list of all currently existing withdraw messages of the batch and paging
/// results that contain next_key and total count.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchWithdrawMsgsResponse {
    #[prost(message, repeated, tag = "1")]
    pub withdraws: ::prost::alloc::vec::Vec<WithdrawMsgState>,
    /// pagination defines the pagination in the response. Not supported on this
    /// version.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// the response type for the QueryPoolBatchWithdrawMsg RPC method. This includes
/// a batch swap message of the batch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolBatchWithdrawMsgResponse {
    #[prost(message, optional, tag = "1")]
    pub withdraw: ::core::option::Option<WithdrawMsgState>,
}
